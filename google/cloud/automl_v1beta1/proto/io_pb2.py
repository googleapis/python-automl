# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/cloud/automl_v1beta1/proto/io.proto

import sys

_b = sys.version_info[0] < 3 and (lambda x: x) or (lambda x: x.encode("latin1"))
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database

# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


from google.api import annotations_pb2 as google_dot_api_dot_annotations__pb2


DESCRIPTOR = _descriptor.FileDescriptor(
    name="google/cloud/automl_v1beta1/proto/io.proto",
    package="google.cloud.automl.v1beta1",
    syntax="proto3",
    serialized_options=_b(
        "\n\037com.google.cloud.automl.v1beta1P\001ZAgoogle.golang.org/genproto/googleapis/cloud/automl/v1beta1;automl\312\002\033Google\\Cloud\\AutoMl\\V1beta1\352\002\036Google::Cloud::AutoML::V1beta1"
    ),
    serialized_pb=_b(
        '\n*google/cloud/automl_v1beta1/proto/io.proto\x12\x1bgoogle.cloud.automl.v1beta1\x1a\x1cgoogle/api/annotations.proto"\x92\x02\n\x0bInputConfig\x12<\n\ngcs_source\x18\x01 \x01(\x0b\x32&.google.cloud.automl.v1beta1.GcsSourceH\x00\x12\x46\n\x0f\x62igquery_source\x18\x03 \x01(\x0b\x32+.google.cloud.automl.v1beta1.BigQuerySourceH\x00\x12\x44\n\x06params\x18\x02 \x03(\x0b\x32\x34.google.cloud.automl.v1beta1.InputConfig.ParamsEntry\x1a-\n\x0bParamsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\x42\x08\n\x06source"\xa9\x01\n\x17\x42\x61tchPredictInputConfig\x12<\n\ngcs_source\x18\x01 \x01(\x0b\x32&.google.cloud.automl.v1beta1.GcsSourceH\x00\x12\x46\n\x0f\x62igquery_source\x18\x02 \x01(\x0b\x32+.google.cloud.automl.v1beta1.BigQuerySourceH\x00\x42\x08\n\x06source"Q\n\x13\x44ocumentInputConfig\x12:\n\ngcs_source\x18\x01 \x01(\x0b\x32&.google.cloud.automl.v1beta1.GcsSource"\xb7\x01\n\x0cOutputConfig\x12\x46\n\x0fgcs_destination\x18\x01 \x01(\x0b\x32+.google.cloud.automl.v1beta1.GcsDestinationH\x00\x12P\n\x14\x62igquery_destination\x18\x02 \x01(\x0b\x32\x30.google.cloud.automl.v1beta1.BigQueryDestinationH\x00\x42\r\n\x0b\x64\x65stination"\xc3\x01\n\x18\x42\x61tchPredictOutputConfig\x12\x46\n\x0fgcs_destination\x18\x01 \x01(\x0b\x32+.google.cloud.automl.v1beta1.GcsDestinationH\x00\x12P\n\x14\x62igquery_destination\x18\x02 \x01(\x0b\x32\x30.google.cloud.automl.v1beta1.BigQueryDestinationH\x00\x42\r\n\x0b\x64\x65stination"\xcf\x02\n\x17ModelExportOutputConfig\x12\x46\n\x0fgcs_destination\x18\x01 \x01(\x0b\x32+.google.cloud.automl.v1beta1.GcsDestinationH\x00\x12\x46\n\x0fgcr_destination\x18\x03 \x01(\x0b\x32+.google.cloud.automl.v1beta1.GcrDestinationH\x00\x12\x14\n\x0cmodel_format\x18\x04 \x01(\t\x12P\n\x06params\x18\x02 \x03(\x0b\x32@.google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry\x1a-\n\x0bParamsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\x42\r\n\x0b\x64\x65stination"\x86\x01\n#ExportEvaluatedExamplesOutputConfig\x12P\n\x14\x62igquery_destination\x18\x02 \x01(\x0b\x32\x30.google.cloud.automl.v1beta1.BigQueryDestinationH\x00\x42\r\n\x0b\x64\x65stination"\x1f\n\tGcsSource\x12\x12\n\ninput_uris\x18\x01 \x03(\t"#\n\x0e\x42igQuerySource\x12\x11\n\tinput_uri\x18\x01 \x01(\t"+\n\x0eGcsDestination\x12\x19\n\x11output_uri_prefix\x18\x01 \x01(\t")\n\x13\x42igQueryDestination\x12\x12\n\noutput_uri\x18\x01 \x01(\t"$\n\x0eGcrDestination\x12\x12\n\noutput_uri\x18\x01 \x01(\tB\xa5\x01\n\x1f\x63om.google.cloud.automl.v1beta1P\x01ZAgoogle.golang.org/genproto/googleapis/cloud/automl/v1beta1;automl\xca\x02\x1bGoogle\\Cloud\\AutoMl\\V1beta1\xea\x02\x1eGoogle::Cloud::AutoML::V1beta1b\x06proto3'
    ),
    dependencies=[google_dot_api_dot_annotations__pb2.DESCRIPTOR],
)


_INPUTCONFIG_PARAMSENTRY = _descriptor.Descriptor(
    name="ParamsEntry",
    full_name="google.cloud.automl.v1beta1.InputConfig.ParamsEntry",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="key",
            full_name="google.cloud.automl.v1beta1.InputConfig.ParamsEntry.key",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="value",
            full_name="google.cloud.automl.v1beta1.InputConfig.ParamsEntry.value",
            index=1,
            number=2,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=_b("8\001"),
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=325,
    serialized_end=370,
)

_INPUTCONFIG = _descriptor.Descriptor(
    name="InputConfig",
    full_name="google.cloud.automl.v1beta1.InputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_source",
            full_name="google.cloud.automl.v1beta1.InputConfig.gcs_source",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="bigquery_source",
            full_name="google.cloud.automl.v1beta1.InputConfig.bigquery_source",
            index=1,
            number=3,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="params",
            full_name="google.cloud.automl.v1beta1.InputConfig.params",
            index=2,
            number=2,
            type=11,
            cpp_type=10,
            label=3,
            has_default_value=False,
            default_value=[],
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[_INPUTCONFIG_PARAMSENTRY],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="source",
            full_name="google.cloud.automl.v1beta1.InputConfig.source",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=106,
    serialized_end=380,
)


_BATCHPREDICTINPUTCONFIG = _descriptor.Descriptor(
    name="BatchPredictInputConfig",
    full_name="google.cloud.automl.v1beta1.BatchPredictInputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_source",
            full_name="google.cloud.automl.v1beta1.BatchPredictInputConfig.gcs_source",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="bigquery_source",
            full_name="google.cloud.automl.v1beta1.BatchPredictInputConfig.bigquery_source",
            index=1,
            number=2,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="source",
            full_name="google.cloud.automl.v1beta1.BatchPredictInputConfig.source",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=383,
    serialized_end=552,
)


_DOCUMENTINPUTCONFIG = _descriptor.Descriptor(
    name="DocumentInputConfig",
    full_name="google.cloud.automl.v1beta1.DocumentInputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_source",
            full_name="google.cloud.automl.v1beta1.DocumentInputConfig.gcs_source",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=554,
    serialized_end=635,
)


_OUTPUTCONFIG = _descriptor.Descriptor(
    name="OutputConfig",
    full_name="google.cloud.automl.v1beta1.OutputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_destination",
            full_name="google.cloud.automl.v1beta1.OutputConfig.gcs_destination",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="bigquery_destination",
            full_name="google.cloud.automl.v1beta1.OutputConfig.bigquery_destination",
            index=1,
            number=2,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="destination",
            full_name="google.cloud.automl.v1beta1.OutputConfig.destination",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=638,
    serialized_end=821,
)


_BATCHPREDICTOUTPUTCONFIG = _descriptor.Descriptor(
    name="BatchPredictOutputConfig",
    full_name="google.cloud.automl.v1beta1.BatchPredictOutputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_destination",
            full_name="google.cloud.automl.v1beta1.BatchPredictOutputConfig.gcs_destination",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="bigquery_destination",
            full_name="google.cloud.automl.v1beta1.BatchPredictOutputConfig.bigquery_destination",
            index=1,
            number=2,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="destination",
            full_name="google.cloud.automl.v1beta1.BatchPredictOutputConfig.destination",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=824,
    serialized_end=1019,
)


_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY = _descriptor.Descriptor(
    name="ParamsEntry",
    full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="key",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry.key",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="value",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry.value",
            index=1,
            number=2,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=_b("8\001"),
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=325,
    serialized_end=370,
)

_MODELEXPORTOUTPUTCONFIG = _descriptor.Descriptor(
    name="ModelExportOutputConfig",
    full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_destination",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.gcs_destination",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="gcr_destination",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.gcr_destination",
            index=1,
            number=3,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="model_format",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.model_format",
            index=2,
            number=4,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="params",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.params",
            index=3,
            number=2,
            type=11,
            cpp_type=10,
            label=3,
            has_default_value=False,
            default_value=[],
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="destination",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.destination",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=1022,
    serialized_end=1357,
)


_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG = _descriptor.Descriptor(
    name="ExportEvaluatedExamplesOutputConfig",
    full_name="google.cloud.automl.v1beta1.ExportEvaluatedExamplesOutputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="bigquery_destination",
            full_name="google.cloud.automl.v1beta1.ExportEvaluatedExamplesOutputConfig.bigquery_destination",
            index=0,
            number=2,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="destination",
            full_name="google.cloud.automl.v1beta1.ExportEvaluatedExamplesOutputConfig.destination",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=1360,
    serialized_end=1494,
)


_GCSSOURCE = _descriptor.Descriptor(
    name="GcsSource",
    full_name="google.cloud.automl.v1beta1.GcsSource",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="input_uris",
            full_name="google.cloud.automl.v1beta1.GcsSource.input_uris",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=3,
            has_default_value=False,
            default_value=[],
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1496,
    serialized_end=1527,
)


_BIGQUERYSOURCE = _descriptor.Descriptor(
    name="BigQuerySource",
    full_name="google.cloud.automl.v1beta1.BigQuerySource",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="input_uri",
            full_name="google.cloud.automl.v1beta1.BigQuerySource.input_uri",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1529,
    serialized_end=1564,
)


_GCSDESTINATION = _descriptor.Descriptor(
    name="GcsDestination",
    full_name="google.cloud.automl.v1beta1.GcsDestination",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="output_uri_prefix",
            full_name="google.cloud.automl.v1beta1.GcsDestination.output_uri_prefix",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1566,
    serialized_end=1609,
)


_BIGQUERYDESTINATION = _descriptor.Descriptor(
    name="BigQueryDestination",
    full_name="google.cloud.automl.v1beta1.BigQueryDestination",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="output_uri",
            full_name="google.cloud.automl.v1beta1.BigQueryDestination.output_uri",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1611,
    serialized_end=1652,
)


_GCRDESTINATION = _descriptor.Descriptor(
    name="GcrDestination",
    full_name="google.cloud.automl.v1beta1.GcrDestination",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="output_uri",
            full_name="google.cloud.automl.v1beta1.GcrDestination.output_uri",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1654,
    serialized_end=1690,
)

_INPUTCONFIG_PARAMSENTRY.containing_type = _INPUTCONFIG
_INPUTCONFIG.fields_by_name["gcs_source"].message_type = _GCSSOURCE
_INPUTCONFIG.fields_by_name["bigquery_source"].message_type = _BIGQUERYSOURCE
_INPUTCONFIG.fields_by_name["params"].message_type = _INPUTCONFIG_PARAMSENTRY
_INPUTCONFIG.oneofs_by_name["source"].fields.append(
    _INPUTCONFIG.fields_by_name["gcs_source"]
)
_INPUTCONFIG.fields_by_name[
    "gcs_source"
].containing_oneof = _INPUTCONFIG.oneofs_by_name["source"]
_INPUTCONFIG.oneofs_by_name["source"].fields.append(
    _INPUTCONFIG.fields_by_name["bigquery_source"]
)
_INPUTCONFIG.fields_by_name[
    "bigquery_source"
].containing_oneof = _INPUTCONFIG.oneofs_by_name["source"]
_BATCHPREDICTINPUTCONFIG.fields_by_name["gcs_source"].message_type = _GCSSOURCE
_BATCHPREDICTINPUTCONFIG.fields_by_name[
    "bigquery_source"
].message_type = _BIGQUERYSOURCE
_BATCHPREDICTINPUTCONFIG.oneofs_by_name["source"].fields.append(
    _BATCHPREDICTINPUTCONFIG.fields_by_name["gcs_source"]
)
_BATCHPREDICTINPUTCONFIG.fields_by_name[
    "gcs_source"
].containing_oneof = _BATCHPREDICTINPUTCONFIG.oneofs_by_name["source"]
_BATCHPREDICTINPUTCONFIG.oneofs_by_name["source"].fields.append(
    _BATCHPREDICTINPUTCONFIG.fields_by_name["bigquery_source"]
)
_BATCHPREDICTINPUTCONFIG.fields_by_name[
    "bigquery_source"
].containing_oneof = _BATCHPREDICTINPUTCONFIG.oneofs_by_name["source"]
_DOCUMENTINPUTCONFIG.fields_by_name["gcs_source"].message_type = _GCSSOURCE
_OUTPUTCONFIG.fields_by_name["gcs_destination"].message_type = _GCSDESTINATION
_OUTPUTCONFIG.fields_by_name["bigquery_destination"].message_type = _BIGQUERYDESTINATION
_OUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _OUTPUTCONFIG.fields_by_name["gcs_destination"]
)
_OUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].containing_oneof = _OUTPUTCONFIG.oneofs_by_name["destination"]
_OUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _OUTPUTCONFIG.fields_by_name["bigquery_destination"]
)
_OUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].containing_oneof = _OUTPUTCONFIG.oneofs_by_name["destination"]
_BATCHPREDICTOUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].message_type = _GCSDESTINATION
_BATCHPREDICTOUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].message_type = _BIGQUERYDESTINATION
_BATCHPREDICTOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _BATCHPREDICTOUTPUTCONFIG.fields_by_name["gcs_destination"]
)
_BATCHPREDICTOUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].containing_oneof = _BATCHPREDICTOUTPUTCONFIG.oneofs_by_name["destination"]
_BATCHPREDICTOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _BATCHPREDICTOUTPUTCONFIG.fields_by_name["bigquery_destination"]
)
_BATCHPREDICTOUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].containing_oneof = _BATCHPREDICTOUTPUTCONFIG.oneofs_by_name["destination"]
_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY.containing_type = _MODELEXPORTOUTPUTCONFIG
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].message_type = _GCSDESTINATION
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "gcr_destination"
].message_type = _GCRDESTINATION
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "params"
].message_type = _MODELEXPORTOUTPUTCONFIG_PARAMSENTRY
_MODELEXPORTOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _MODELEXPORTOUTPUTCONFIG.fields_by_name["gcs_destination"]
)
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].containing_oneof = _MODELEXPORTOUTPUTCONFIG.oneofs_by_name["destination"]
_MODELEXPORTOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _MODELEXPORTOUTPUTCONFIG.fields_by_name["gcr_destination"]
)
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "gcr_destination"
].containing_oneof = _MODELEXPORTOUTPUTCONFIG.oneofs_by_name["destination"]
_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].message_type = _BIGQUERYDESTINATION
_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.fields_by_name["bigquery_destination"]
)
_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].containing_oneof = _EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.oneofs_by_name["destination"]
DESCRIPTOR.message_types_by_name["InputConfig"] = _INPUTCONFIG
DESCRIPTOR.message_types_by_name["BatchPredictInputConfig"] = _BATCHPREDICTINPUTCONFIG
DESCRIPTOR.message_types_by_name["DocumentInputConfig"] = _DOCUMENTINPUTCONFIG
DESCRIPTOR.message_types_by_name["OutputConfig"] = _OUTPUTCONFIG
DESCRIPTOR.message_types_by_name["BatchPredictOutputConfig"] = _BATCHPREDICTOUTPUTCONFIG
DESCRIPTOR.message_types_by_name["ModelExportOutputConfig"] = _MODELEXPORTOUTPUTCONFIG
DESCRIPTOR.message_types_by_name[
    "ExportEvaluatedExamplesOutputConfig"
] = _EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG
DESCRIPTOR.message_types_by_name["GcsSource"] = _GCSSOURCE
DESCRIPTOR.message_types_by_name["BigQuerySource"] = _BIGQUERYSOURCE
DESCRIPTOR.message_types_by_name["GcsDestination"] = _GCSDESTINATION
DESCRIPTOR.message_types_by_name["BigQueryDestination"] = _BIGQUERYDESTINATION
DESCRIPTOR.message_types_by_name["GcrDestination"] = _GCRDESTINATION
_sym_db.RegisterFileDescriptor(DESCRIPTOR)

InputConfig = _reflection.GeneratedProtocolMessageType(
    "InputConfig",
    (_message.Message,),
    dict(
        ParamsEntry=_reflection.GeneratedProtocolMessageType(
            "ParamsEntry",
            (_message.Message,),
            dict(
                DESCRIPTOR=_INPUTCONFIG_PARAMSENTRY,
                __module__="google.cloud.automl_v1beta1.proto.io_pb2"
                # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.InputConfig.ParamsEntry)
            ),
        ),
        DESCRIPTOR=_INPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Input configuration for ImportData Action.  The format of input
  depends on dataset\_metadata the Dataset into which the import is
  happening has. As input source the
  [gcs\_source][google.cloud.automl.v1beta1.InputConfig.gcs\_source] is
  expected, unless specified otherwise. Additionally any input .CSV file
  by itself must be 100MB or smaller, unless specified otherwise. If an
  "example" file (that is, image, video etc.) with identical content
  (even if it had different GCS\_FILE\_PATH) is mentioned multiple
  times, then its label, bounding boxes etc. are appended. The same file
  should be always provided with the same ML\_USE and GCS\_FILE\_PATH,
  if it is not, then these values are nondeterministically selected from
  the given ones.  The formats are represented in EBNF with commas being
  literal and with non-terminal symbols defined near the end of this
  comment. The formats are:  -  For Image Classification: CSV file(s)
  with each line in format:    ML\_USE,GCS\_FILE\_PATH,LABEL,LABEL,...
  GCS\_FILE\_PATH leads to    image of up to 30MB in size. Supported
  extensions: .JPEG, .GIF, .PNG,    .WEBP, .BMP, .TIFF, .ICO For
  MULTICLASS classification type, at most    one LABEL is allowed per
  image. If an image has not yet been labeled,    then it should be
  mentioned just once with no LABEL. Some sample    rows:
  TRAIN,gs://folder/image1.jpg,daisy
  TEST,gs://folder/image2.jpg,dandelion,tulip,rose
  UNASSIGNED,gs://folder/image3.jpg,daisy
  UNASSIGNED,gs://folder/image4.jpg  -  For Image Object Detection: CSV
  file(s) with each line in format:
  ML\_USE,GCS\_FILE\_PATH,(LABEL,BOUNDING\_BOX \| ,,,,,,,)
  GCS\_FILE\_PATH leads to image of up to 30MB in size. Supported
  extensions: .JPEG, .GIF, .PNG. Each image is assumed to be
  exhaustively labeled. The minimum allowed BOUNDING\_BOX edge length
  is 0.01, and no more than 500 BOUNDING\_BOX-es per image are allowed
  (one BOUNDING\_BOX is defined per line). If an image has not yet been
  labeled, then it should be mentioned just once with no LABEL and the
  ",,,,,,," in place of the BOUNDING\_BOX. For images which are known
  to not contain any bounding boxes, they should be labelled explictly
  as "NEGATIVE\_IMAGE", followed by ",,,,,,," in place of the
  BOUNDING\_BOX. Sample rows:
  TRAIN,gs://folder/image1.png,car,0.1,0.1,,,0.3,0.3,,
  TRAIN,gs://folder/image1.png,bike,.7,.6,,,.8,.9,,
  UNASSIGNED,gs://folder/im2.png,car,0.1,0.1,0.2,0.1,0.2,0.3,0.1,0.3
  TEST,gs://folder/im3.png,,,,,,,,,
  TRAIN,gs://folder/im4.png,NEGATIVE\_IMAGE,,,,,,,,,  -  For Video
  Classification: CSV file(s) with each line in format:
  ML\_USE,GCS\_FILE\_PATH where ML\_USE VALIDATE value should not be
  used. The GCS\_FILE\_PATH should lead to another .csv file which
  describes examples that have given ML\_USE, using the following row
  format:
  GCS\_FILE\_PATH,(LABEL,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END \| ,,)
  Here GCS\_FILE\_PATH leads to a video of up to 50GB in size and up to
  3h duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI.
  TIME\_SEGMENT\_START and TIME\_SEGMENT\_END must be within the length
  of the video, and end has to be after the start. Any segment of a
  video which has one or more labels on it, is considered a hard
  negative for all other labels. Any segment with no labels on it is
  considered to be unknown. If a whole video is unknown, then it shuold
  be mentioned just once with ",," in place of LABEL,
  TIME\_SEGMENT\_START,TIME\_SEGMENT\_END. Sample top level CSV file:
  TRAIN,gs://folder/train\_videos.csv TEST,gs://folder/test\_videos.csv
  UNASSIGNED,gs://folder/other\_videos.csv Sample rows of a CSV file
  for a particular ML\_USE: gs://folder/video1.avi,car,120,180.000021
  gs://folder/video1.avi,bike,150,180.000021
  gs://folder/vid2.avi,car,0,60.5 gs://folder/vid3.avi,,,  -  For Video
  Object Tracking: CSV file(s) with each line in format:
  ML\_USE,GCS\_FILE\_PATH where ML\_USE VALIDATE value should not be
  used. The GCS\_FILE\_PATH should lead to another .csv file which
  describes examples that have given ML\_USE, using one of the
  following row format:
  GCS\_FILE\_PATH,LABEL,[INSTANCE\_ID],TIMESTAMP,BOUNDING\_BOX or
  GCS\_FILE\_PATH,,,,,,,,,, Here GCS\_FILE\_PATH leads to a video of up
  to 50GB in size and up to 3h duration. Supported extensions: .MOV,
  .MPEG4, .MP4, .AVI. Providing INSTANCE\_IDs can help to obtain a
  better model. When a specific labeled entity leaves the video frame,
  and shows up afterwards it is not required, albeit preferable, that
  the same INSTANCE\_ID is given to it. TIMESTAMP must be within the
  length of the video, the BOUNDING\_BOX is assumed to be drawn on the
  closest video's frame to the TIMESTAMP. Any mentioned by the
  TIMESTAMP frame is expected to be exhaustively labeled and no more
  than 500 BOUNDING\_BOX-es per frame are allowed. If a whole video is
  unknown, then it should be mentioned just once with ",,,,,,,,,," in
  place of LABEL, [INSTANCE\_ID],TIMESTAMP,BOUNDING\_BOX. Sample top
  level CSV file: TRAIN,gs://folder/train\_videos.csv
  TEST,gs://folder/test\_videos.csv
  UNASSIGNED,gs://folder/other\_videos.csv Seven sample rows of a CSV
  file for a particular ML\_USE:
  gs://folder/video1.avi,car,1,12.10,0.8,0.8,0.9,0.8,0.9,0.9,0.8,0.9
  gs://folder/video1.avi,car,1,12.90,0.4,0.8,0.5,0.8,0.5,0.9,0.4,0.9
  gs://folder/video1.avi,car,2,12.10,.4,.2,.5,.2,.5,.3,.4,.3
  gs://folder/video1.avi,car,2,12.90,.8,.2,,,.9,.3,,
  gs://folder/video1.avi,bike,,12.50,.45,.45,,,.55,.55,,
  gs://folder/video2.avi,car,1,0,.1,.9,,,.9,.1,,
  gs://folder/video2.avi,,,,,,,,,,, -  For Text Extraction: CSV file(s)
  with each line in format:    ML\_USE,GCS\_FILE\_PATH GCS\_FILE\_PATH
  leads to a .JSONL (that is,    JSON Lines) file which either imports
  text in-line or as documents.    Any given .JSONL file must be 100MB
  or smaller. The in-line .JSONL    file contains, per line, a proto
  that wraps a TextSnippet proto (in    json representation) followed by
  one or more AnnotationPayload protos    (called annotations), which
  have display\_name and text\_extraction    detail populated. The given
  text is expected to be annotated    exhaustively, for example, if you
  look for animals and text contains    "dolphin" that is not labeled,
  then "dolphin" is assumed to not be an    animal. Any given text
  snippet content must be 10KB or smaller, and    also be UTF-8 NFC
  encoded (ASCII already is). The document .JSONL    file contains, per
  line, a proto that wraps a Document proto. The    Document proto must
  have either document\_text or input\_config set.    In document\_text
  case, the Document proto may also contain the    spatial information
  of the document, including layout, document    dimension and page
  number. In input\_config case, only PDF documents    are supported
  now, and each document may be up to 2MB large.    Currently,
  annotations on documents cannot be specified at import.    Three
  sample CSV rows: TRAIN,gs://folder/file1.jsonl
  VALIDATE,gs://folder/file2.jsonl TEST,gs://folder/file3.jsonl Sample
  in-line JSON Lines file for entity extraction (presented here with
  artificial line breaks, but the only actual line break is denoted by
  :raw-latex:`\n`).: { "document": { "document\_text": {"content": "dog
  cat"} "layout": [ { "text\_segment": { "start\_offset": 0,
  "end\_offset": 3, }, "page\_number": 1, "bounding\_poly": {
  "normalized\_vertices": [ {"x": 0.1, "y": 0.1}, {"x": 0.1, "y": 0.3},
  {"x": 0.3, "y": 0.3}, {"x": 0.3, "y": 0.1}, ], },
  "text\_segment\_type": TOKEN, }, { "text\_segment": {
  "start\_offset": 4, "end\_offset": 7, }, "page\_number": 1,
  "bounding\_poly": { "normalized\_vertices": [ {"x": 0.4, "y": 0.1},
  {"x": 0.4, "y": 0.3}, {"x": 0.8, "y": 0.3}, {"x": 0.8, "y": 0.1}, ],
  }, "text\_segment\_type": TOKEN, }     ::               ],
  "document_dimensions": {                "width": 8.27,
  "height": 11.69,                "unit": INCH,              }
  "page_count": 1,            },            "annotations": [
  {                "display_name": "animal",
  "text_extraction": {"text_segment": {"start_offset": 0,
  "end_offset": 3}}              },              {
  "display_name": "animal",                "text_extraction":
  {"text_segment": {"start_offset": 4,                "end_offset": 7}}
  }            ],          }\\n          {             "text_snippet": {
  "content": "This dog is good."             },
  "annotations": [               {                 "display_name":
  "animal",                 "text_extraction": {
  "text_segment": {"start_offset": 5, "end_offset": 8}                 }
  }             ]          }        Sample document JSON Lines file
  (presented here with artificial line        breaks, but the only
  actual line break is denoted by \n).:          {
  "document": {              "input_config": {
  "gcs_source": { "input_uris": [ "gs://folder/document1.pdf" ]
  }              }            }          }\\n          {
  "document": {              "input_config": {
  "gcs_source": { "input_uris": [ "gs://folder/document2.pdf" ]
  }              }            }          }  -  For Text Classification:
  CSV file(s) with each line in format:    ML\_USE,(TEXT\_SNIPPET \|
  GCS\_FILE\_PATH),LABEL,LABEL,...    TEXT\_SNIPPET and GCS\_FILE\_PATH
  are distinguished by a pattern. If    the column content is a valid
  gcs file path, i.e. prefixed by    "gs://", it will be treated as a
  GCS\_FILE\_PATH, else if the content    is enclosed within double
  quotes (""), it is treated as a    TEXT\_SNIPPET. In the
  GCS\_FILE\_PATH case, the path must lead to a    .txt file with UTF-8
  encoding, for example,    "gs://folder/content.txt", and the content
  in it is extracted as a    text snippet. In TEXT\_SNIPPET case, the
  column content excluding    quotes is treated as to be imported text
  snippet. In both cases, the    text snippet/file size must be within
  128kB. Maximum 100 unique    labels are allowed per CSV row. Sample
  rows: TRAIN,"They have bad    food and very rude",RudeService,BadFood
  TRAIN,gs://folder/content.txt,SlowService TEST,"Typically always bad
  service there.",RudeService VALIDATE,"Stomach ache to go.",BadFood  -
  For Text Sentiment: CSV file(s) with each line in format:
  ML\_USE,(TEXT\_SNIPPET \| GCS\_FILE\_PATH),SENTIMENT TEXT\_SNIPPET
  and GCS\_FILE\_PATH are distinguished by a pattern. If the column
  content is a valid gcs file path, that is, prefixed by "gs://", it is
  treated as a GCS\_FILE\_PATH, otherwise it is treated as a
  TEXT\_SNIPPET. In the GCS\_FILE\_PATH case, the path must lead to a
  .txt file with UTF-8 encoding, for example,
  "gs://folder/content.txt", and the content in it is extracted as a
  text snippet. In TEXT\_SNIPPET case, the column content itself is
  treated as to be imported text snippet. In both cases, the text
  snippet must be up to 500 characters long. Sample rows:
  TRAIN,"@freewrytin this is way too good for your product",2 TRAIN,"I
  need this product so bad",3 TEST,"Thank you for this product.",4
  VALIDATE,gs://folder/content.txt,2  -  For Tables: Either
  [gcs\_source][google.cloud.automl.v1beta1.InputConfig.gcs\_source] or
  [bigquery\_source][google.cloud.automl.v1beta1.InputConfig.bigquery\_s
  ource] can be used. All inputs is concatenated into a single  [primary
  \_table][google.cloud.automl.v1beta1.TablesDatasetMetadata.primary\_ta
  ble\_name] For gcs\_source: CSV file(s), where the first row of the
  first file is the header, containing unique column names. If the first
  row of a subsequent file is the same as the header, then it is also
  treated as a header. All other rows contain values for the
  corresponding columns. Each .CSV file by itself must be 10GB or
  smaller, and their total size must be 100GB or smaller. First three
  sample rows of a CSV file: "Id","First Name","Last
  Name","Dob","Addresses"  "1","John","Doe","1968-01-22","[{"status":"cu
  rrent","address":"123\_First\_Avenue","city":"Seattle","state":"WA","z
  ip":"11111","numberOfYears":"1"},{"status":"previous","address":"456\_
  Main\_Street","city":"Portland","state":"OR","zip":"22222","numberOfYe
  ars":"5"}]"  "2","Jane","Doe","1980-10-16","[{"status":"current","addr
  ess":"789\_Any\_Avenue","city":"Albany","state":"NY","zip":"33333","nu
  mberOfYears":"2"},{"status":"previous","address":"321\_Main\_Street","
  city":"Hoboken","state":"NJ","zip":"44444","numberOfYears":"3"}]} For
  bigquery\_source: An URI of a BigQuery table. The user data size of
  the BigQuery table must be 100GB or smaller. An imported table must
  have between 2 and 1,000 columns, inclusive, and between 1000 and
  100,000,000 rows, inclusive. There are at most 5 import data running
  in parallel. Definitions: ML\_USE = "TRAIN" \| "VALIDATE" \| "TEST" \|
  "UNASSIGNED" Describes how the given example (file) should be used for
  model training. "UNASSIGNED" can be used when user has no preference.
  GCS\_FILE\_PATH = A path to file on GCS, e.g.
  "gs://folder/image1.png". LABEL = A display name of an object on an
  image, video etc., e.g. "dog". Must be up to 32 characters long and
  can consist only of ASCII Latin letters A-Z and a-z, underscores(\_),
  and ASCII digits 0-9. For each label an AnnotationSpec is created
  which display\_name becomes the label; AnnotationSpecs are given back
  in predictions. INSTANCE\_ID = A positive integer that identifies a
  specific instance of a labeled entity on an example. Used e.g. to
  track two cars on a video while being able to tell apart which one is
  which. BOUNDING\_BOX = VERTEX,VERTEX,VERTEX,VERTEX \|
  VERTEX,,,VERTEX,, A rectangle parallel to the frame of the example
  (image, video). If 4 vertices are given they are connected by edges in
  the order provided, if 2 are given they are recognized as diagonally
  opposite vertices of the rectangle. VERTEX = COORDINATE,COORDINATE
  First coordinate is horizontal (x), the second is vertical (y).
  COORDINATE = A float in 0 to 1 range, relative to total length of
  image or video in given dimension. For fractions the leading non-
  decimal 0 can be omitted (i.e. 0.3 = .3). Point 0,0 is in top left.
  TIME\_SEGMENT\_START = TIME\_OFFSET Expresses a beginning, inclusive,
  of a time segment within an example that has a time dimension (e.g.
  video). TIME\_SEGMENT\_END = TIME\_OFFSET Expresses an end, exclusive,
  of a time segment within an example that has a time dimension (e.g.
  video). TIME\_OFFSET = A number of seconds as measured from the start
  of an example (e.g. video). Fractions are allowed, up to a microsecond
  precision. "inf" is allowed, and it means the end of the example.
  TEXT\_SNIPPET = A content of a text snippet, UTF-8 encoded, enclosed
  within double quotes (""). SENTIMENT = An integer between 0 and
  Dataset.text\_sentiment\_dataset\_metadata.sentiment\_max (inclusive).
  Describes the ordinal of the sentiment - higher value means a more
  positive sentiment. All the values are completely relative, i.e.
  neither 0 needs to mean a negative or neutral sentiment nor
  sentiment\_max needs to mean a positive one - it is just required that
  0 is the least positive sentiment in the data, and sentiment\_max is
  the most positive one. The SENTIMENT shouldn't be confused with
  "score" or "magnitude" from the previous Natural Language Sentiment
  Analysis API. All SENTIMENT values between 0 and sentiment\_max must
  be represented in the imported data. On prediction the same 0 to
  sentiment\_max range will be used. The difference between neighboring
  sentiment values needs not to be uniform, e.g. 1 and 2 may be similar
  whereas the difference between 2 and 3 may be huge.  Errors: If any of
  the provided CSV files can't be parsed or if more than certain percent
  of CSV rows cannot be processed then the operation fails and nothing
  is imported. Regardless of overall success or failure the per-row
  failures, up to a certain count cap, is listed in
  Operation.metadata.partial\_failures.
  Attributes:
      source:
          The source of the input.
      gcs_source:
          The Google Cloud Storage location for the input content. In
          ImportData, the gcs\_source points to a csv with structure
          described in the comment.
      bigquery_source:
          The BigQuery location for the input content.
      params:
          Additional domain-specific parameters describing the semantic
          of the imported data, any string must be up to 25000
          characters long.  -  For Tables: ``schema_inference_version``
          - (integer) Required. The    version of the algorithm that
          should be used for the initial    inference of the schema
          (columns' DataTypes) of the table the data is    being
          imported into. Allowed values: "1".
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.InputConfig)
    ),
)
_sym_db.RegisterMessage(InputConfig)
_sym_db.RegisterMessage(InputConfig.ParamsEntry)

BatchPredictInputConfig = _reflection.GeneratedProtocolMessageType(
    "BatchPredictInputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_BATCHPREDICTINPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Input configuration for BatchPredict Action.  The format of input
  depends on the ML problem of the model used for prediction. As input
  source the
  [gcs\_source][google.cloud.automl.v1beta1.InputConfig.gcs\_source] is
  expected, unless specified otherwise.  The formats are represented in
  EBNF with commas being literal and with non-terminal symbols defined
  near the end of this comment. The formats are:  -  For Image
  Classification: CSV file(s) with each line having just a    single
  column: GCS\_FILE\_PATH which leads to image of up to 30MB in    size.
  Supported extensions: .JPEG, .GIF, .PNG. This path is treated    as
  the ID in the Batch predict output. Three sample rows:
  gs://folder/image1.jpeg gs://folder/image2.gif gs://folder/image3.png
  -  For Image Object Detection: CSV file(s) with each line having just
  a    single column: GCS\_FILE\_PATH which leads to image of up to 30MB
  in    size. Supported extensions: .JPEG, .GIF, .PNG. This path is
  treated    as the ID in the Batch predict output. Three sample rows:
  gs://folder/image1.jpeg gs://folder/image2.gif gs://folder/image3.png
  -  For Video Classification: CSV file(s) with each line in format:
  GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END
  GCS\_FILE\_PATH leads to video of up to 50GB in size and up to 3h
  duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI.
  TIME\_SEGMENT\_START and TIME\_SEGMENT\_END must be within the length
  of the video, and end has to be after the start. Three sample rows:
  gs://folder/video1.mp4,10,40 gs://folder/video1.mp4,20,60
  gs://folder/vid2.mov,0,inf  -  For Video Object Tracking: CSV file(s)
  with each line in format:
  GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END
  GCS\_FILE\_PATH leads to video of up to 50GB in size and up to 3h
  duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI.
  TIME\_SEGMENT\_START and TIME\_SEGMENT\_END must be within the length
  of the video, and end has to be after the start. Three sample rows:
  gs://folder/video1.mp4,10,240 gs://folder/video1.mp4,300,360
  gs://folder/vid2.mov,0,inf -  For Text Classification: CSV file(s)
  with each line having just a    single column: GCS\_FILE\_PATH \|
  TEXT\_SNIPPET Any given text file    can have size upto 128kB. Any
  given text snippet content must have    60,000 characters or less.
  Three sample rows: gs://folder/text1.txt    "Some text content to
  predict" gs://folder/text3.pdf Supported file    extensions: .txt,
  .pdf  -  For Text Sentiment: CSV file(s) with each line having just a
  single    column: GCS\_FILE\_PATH \| TEXT\_SNIPPET Any given text file
  can have    size upto 128kB. Any given text snippet content must have
  500    characters or less. Three sample rows: gs://folder/text1.txt
  "Some    text content to predict" gs://folder/text3.pdf Supported file
  extensions: .txt, .pdf  -  For Text Extraction .JSONL (i.e. JSON
  Lines) file(s) which either    provide text in-line or as documents
  (for a single BatchPredict call    only one of the these formats may
  be used). The in-line .JSONL    file(s) contain per line a proto that
  wraps a temporary user-assigned    TextSnippet ID (string up to 2000
  characters long) called "id", a    TextSnippet proto (in json
  representation) and zero or more    TextFeature protos. Any given text
  snippet content must have 30,000    characters or less, and also be
  UTF-8 NFC encoded (ASCII already is).    The IDs provided should be
  unique. The document .JSONL file(s)    contain, per line, a proto that
  wraps a Document proto with    input\_config set. Only PDF documents
  are supported now, and each    document must be up to 2MB large. Any
  given .JSONL file must be 100MB    or smaller, and no more than 20
  files may be given. Sample in-line    JSON Lines file (presented here
  with artificial line breaks, but the    only actual line break is
  denoted by :raw-latex:`\n`): { "id":    "my\_first\_id",
  "text\_snippet": { "content": "dog car cat"},    "text\_features": [ {
  "text\_segment": {"start\_offset": 4,    "end\_offset": 6},
  "structural\_type": PARAGRAPH, "bounding\_poly": {
  "normalized\_vertices": [ {"x": 0.1, "y": 0.1}, {"x": 0.1, "y": 0.3},
  {"x": 0.3, "y": 0.3}, {"x": 0.3, "y": 0.1}, ] }, } ], }:raw-latex:`\n
  {            "id": "2",            "text_snippet": {
  "content": "An elaborate content",              "mime_type":
  "text/plain"            }          }` Sample document JSON Lines file
  (presented here with    artificial line breaks, but the only actual
  line break is denoted by    :raw-latex:`\n`).: { "document": {
  "input\_config": { "gcs\_source":    { "input\_uris": [
  "gs://folder/document1.pdf" ] } } }    }:raw-latex:`\n          {
  "document": {              "input_config": {
  "gcs_source": { "input_uris": [ "gs://folder/document2.pdf" ]
  }              }            }          }`  -  For Tables: Either
  [gcs\_source][google.cloud.automl.v1beta1.InputConfig.gcs\_source] or
  [bigquery\_source][google.cloud.automl.v1beta1.InputConfig.bigquery\_s
  ource]. GCS case: CSV file(s), each by itself 10GB or smaller and
  total size must be 100GB or smaller, where first file must have a
  header containing column names. If the first row of a subsequent file
  is the same as the header, then it is also treated as a header. All
  other rows contain values for the corresponding columns. The column
  names must contain the model's  [input\_feature\_column\_specs'][googl
  e.cloud.automl.v1beta1.TablesModelMetadata.input\_feature\_column\_spe
  cs]  [display\_name-s][google.cloud.automl.v1beta1.ColumnSpec.display\
  _name] (order doesn't matter). The columns corresponding to the
  model's input feature column specs must contain values compatible with
  the column spec's data types. Prediction on all the rows, i.e. the CSV
  lines, will be attempted. For FORECASTING  [prediction\_type][google.c
  loud.automl.v1beta1.TablesModelMetadata.prediction\_type]: all columns
  having  [TIME\_SERIES\_AVAILABLE\_PAST\_ONLY][google.cloud.automl.v1be
  ta1.ColumnSpec.ForecastingMetadata.ColumnType] type will be ignored.
  First three sample rows of a CSV file: "First Name","Last
  Name","Dob","Addresses"  "John","Doe","1968-01-22","[{"status":"curren
  t","address":"123\_First\_Avenue","city":"Seattle","state":"WA","zip":
  "11111","numberOfYears":"1"},{"status":"previous","address":"456\_Main
  \_Street","city":"Portland","state":"OR","zip":"22222","numberOfYears"
  :"5"}]"  "Jane","Doe","1980-10-16","[{"status":"current","address":"78
  9\_Any\_Avenue","city":"Albany","state":"NY","zip":"33333","numberOfYe
  ars":"2"},{"status":"previous","address":"321\_Main\_Street","city":"H
  oboken","state":"NJ","zip":"44444","numberOfYears":"3"}]} BigQuery
  case: An URI of a BigQuery table. The user data size of the BigQuery
  table must be 100GB or smaller. The column names must contain the
  model's  [input\_feature\_column\_specs'][google.cloud.automl.v1beta1.
  TablesModelMetadata.input\_feature\_column\_specs]  [display\_name-s][
  google.cloud.automl.v1beta1.ColumnSpec.display\_name] (order doesn't
  matter). The columns corresponding to the model's input feature column
  specs must contain values compatible with the column spec's data
  types. Prediction on all the rows of the table will be attempted. For
  FORECASTING  [prediction\_type][google.cloud.automl.v1beta1.TablesMode
  lMetadata.prediction\_type]: all columns having  [TIME\_SERIES\_AVAILA
  BLE\_PAST\_ONLY][google.cloud.automl.v1beta1.ColumnSpec.ForecastingMet
  adata.ColumnType] type will be ignored.  Definitions: GCS\_FILE\_PATH
  = A path to file on GCS, e.g. "gs://folder/video.avi". TEXT\_SNIPPET =
  A content of a text snippet, UTF-8 encoded, enclosed within double
  quotes ("") TIME\_SEGMENT\_START = TIME\_OFFSET Expresses a beginning,
  inclusive, of a time segment within an example that has a time
  dimension (e.g. video). TIME\_SEGMENT\_END = TIME\_OFFSET Expresses an
  end, exclusive, of a time segment within an example that has a time
  dimension (e.g. video). TIME\_OFFSET = A number of seconds as measured
  from the start of an example (e.g. video). Fractions are allowed, up
  to a microsecond precision. "inf" is allowed and it means the end of
  the example.  Errors: If any of the provided CSV files can't be parsed
  or if more than certain percent of CSV rows cannot be processed then
  the operation fails and prediction does not happen. Regardless of
  overall success or failure the per-row failures, up to a certain count
  cap, will be listed in Operation.metadata.partial\_failures.
  Attributes:
      source:
          Required. The source of the input.
      gcs_source:
          The Google Cloud Storage location for the input content.
      bigquery_source:
          The BigQuery location for the input content.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.BatchPredictInputConfig)
    ),
)
_sym_db.RegisterMessage(BatchPredictInputConfig)

DocumentInputConfig = _reflection.GeneratedProtocolMessageType(
    "DocumentInputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_DOCUMENTINPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Input configuration of a
  [Document][google.cloud.automl.v1beta1.Document].
  Attributes:
      gcs_source:
          The Google Cloud Storage location of the document file. Only a
          single path should be given. Max supported size: 512MB.
          Supported extensions: .PDF.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.DocumentInputConfig)
    ),
)
_sym_db.RegisterMessage(DocumentInputConfig)

OutputConfig = _reflection.GeneratedProtocolMessageType(
    "OutputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_OUTPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""\* For Translation: CSV file ``translation.csv``, with each line in
  format: ML\_USE,GCS\_FILE\_PATH GCS\_FILE\_PATH leads to a .TSV file
  which describes examples that have given ML\_USE, using the following
  row format per line: TEXT\_SNIPPET (in source language) :raw-latex:`\t
  `TEXT\_SNIPPET (in target language)  -  For Tables: Output depends on
  whether the dataset was imported from    GCS or BigQuery. GCS case:  [
  gcs\_destination][google.cloud.automl.v1beta1.OutputConfig.gcs\_destin
  ation] must be set. Exported are CSV file(s) ``tables_1.csv``,
  ``tables_2.csv``,...,\ ``tables_N.csv`` with each having as header
  line the table's column names, and all other lines contain values for
  the header columns. BigQuery case:  [bigquery\_destination][google.clo
  ud.automl.v1beta1.OutputConfig.bigquery\_destination] pointing to a
  BigQuery project must be set. In the given project a new dataset will
  be created with name  ``export_data_<automl-dataset-display-
  name>_<timestamp-of-export-call>`` where will be made BigQuery-
  dataset-name compatible (e.g. most special characters will become
  underscores), and timestamp will be in YYYY\_MM\_DDThh\_mm\_ss\_sssZ
  "based on ISO-8601" format. In that dataset a new table called
  ``primary_table`` will be created, and filled with precisely the same
  data as this obtained on import.
  Attributes:
      destination:
          Required. The destination of the output.
      gcs_destination:
          The Google Cloud Storage location where the output is to be
          written to. For Image Object Detection, Text Extraction, Video
          Classification and Tables, in the given directory a new
          directory will be created with name: export\_data-- where
          timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. All
          export output will be written into that directory.
      bigquery_destination:
          The BigQuery location where the output is to be written to.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.OutputConfig)
    ),
)
_sym_db.RegisterMessage(OutputConfig)

BatchPredictOutputConfig = _reflection.GeneratedProtocolMessageType(
    "BatchPredictOutputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_BATCHPREDICTOUTPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Output configuration for BatchPredict Action.  As destination the  [gc
  s\_destination][google.cloud.automl.v1beta1.BatchPredictOutputConfig.g
  cs\_destination] must be set unless specified otherwise for a domain.
  If gcs\_destination is set then in the given directory a new directory
  is created. Its name will be "prediction--", where timestamp is in
  YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. The contents of it depends
  on the ML problem the predictions are made for.  -  For Image
  Classification: In the created directory files
  ``image_classification_1.jsonl``,
  ``image_classification_2.jsonl``,...,\
  ``image_classification_N.jsonl``    will be created, where N may be 1,
  and depends on the total number of    the successfully predicted
  images and annotations. A single image    will be listed only once
  with all its annotations, and its    annotations will never be split
  across files. Each .JSONL file will    contain, per line, a JSON
  representation of a proto that wraps    image's "ID" : "" followed by
  a list of zero or more    AnnotationPayload protos (called
  annotations), which have    classification detail populated. If
  prediction for any image failed    (partially or completely), then an
  additional ``errors_1.jsonl``,    ``errors_2.jsonl``,...,
  ``errors_N.jsonl`` files will be created (N    depends on total number
  of failed predictions). These files will have    a JSON representation
  of a proto that wraps the same "ID" : "" but    here followed by
  exactly one  ```google.rpc.Status`` <https:%20//github.com/googleapis/
  googleapis/blob/master/google/rpc/status.proto>`__ containing only
  ``code`` and ``message``\ fields.  -  For Image Object Detection: In
  the created directory files    ``image_object_detection_1.jsonl``,
  ``image_object_detection_2.jsonl``,...,\
  ``image_object_detection_N.jsonl``    will be created, where N may be
  1, and depends on the total number of    the successfully predicted
  images and annotations. Each .JSONL file    will contain, per line, a
  JSON representation of a proto that wraps    image's "ID" : ""
  followed by a list of zero or more    AnnotationPayload protos (called
  annotations), which have    image\_object\_detection detail populated.
  A single image will be    listed only once with all its annotations,
  and its annotations will    never be split across files. If prediction
  for any image failed    (partially or completely), then additional
  ``errors_1.jsonl``,    ``errors_2.jsonl``,..., ``errors_N.jsonl``
  files will be created (N    depends on total number of failed
  predictions). These files will have    a JSON representation of a
  proto that wraps the same "ID" : "" but    here followed by exactly
  one  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleap
  is/blob/master/google/rpc/status.proto>`__ containing only ``code``
  and ``message``\ fields. \* For Video Classification: In the created
  directory a video\_classification.csv file, and a .JSON file per each
  video classification requested in the input (i.e. each line in given
  CSV(s)), will be created.  ::          The format of
  video_classification.csv is:  GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIM
  E\_SEGMENT\_END,JSON\_FILE\_NAME,STATUS where:
  GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END = matches 1 to
  1 the prediction input lines (i.e. video\_classification.csv has
  precisely the same number of lines as the prediction input had.)
  JSON\_FILE\_NAME = Name of .JSON file in the output directory, which
  contains prediction responses for the video time segment. STATUS =
  "OK" if prediction completed successfully, or an error code with
  message otherwise. If STATUS is not "OK" then the .JSON file for that
  line may not exist or be empty.  ::          Each .JSON file, assuming
  STATUS is "OK", will contain a list of         AnnotationPayload
  protos in JSON format, which are the predictions         for the video
  time segment the file is assigned to in the
  video_classification.csv. All AnnotationPayload protos will have
  video_classification field set, and will be sorted by
  video_classification.type field (note that the returned types are
  governed by `classifaction_types` parameter in
  [PredictService.BatchPredictRequest.params][]).  -  For Video Object
  Tracking: In the created directory a    video\_object\_tracking.csv
  file will be created, and multiple files
  video\_object\_trackinng\_1.json,
  video\_object\_trackinng\_2.json,...,
  video\_object\_trackinng\_N.json, where N is the number of requests
  in the input (i.e. the number of lines in given CSV(s)).     ::
  The format of video_object_tracking.csv is:  GCS\_FILE\_PATH,TIME\_SEG
  MENT\_START,TIME\_SEGMENT\_END,JSON\_FILE\_NAME,STATUS where:
  GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END = matches 1 to
  1 the prediction input lines (i.e. video\_object\_tracking.csv has
  precisely the same number of lines as the prediction input had.)
  JSON\_FILE\_NAME = Name of .JSON file in the output directory, which
  contains prediction responses for the video time segment. STATUS =
  "OK" if prediction completed successfully, or an error code with
  message otherwise. If STATUS is not "OK" then the .JSON file for that
  line may not exist or be empty.  ::          Each .JSON file, assuming
  STATUS is "OK", will contain a list of         AnnotationPayload
  protos in JSON format, which are the predictions         for each
  frame of the video time segment the file is assigned to in
  video_object_tracking.csv. All AnnotationPayload protos will have
  video_object_tracking field set.  -  For Text Classification: In the
  created directory files    ``text_classification_1.jsonl``,
  ``text_classification_2.jsonl``,...,\ ``text_classification_N.jsonl``
  will be created, where N may be 1, and depends on the total number of
  inputs and annotations found.     ::         Each .JSONL file will
  contain, per line, a JSON representation of a        proto that wraps
  input text snippet or input text file and a list of        zero or
  more AnnotationPayload protos (called annotations), which        have
  classification detail populated. A single text snippet or file
  will be listed only once with all its annotations, and its
  annotations will never be split across files.         If prediction
  for any text snippet or file failed (partially or        completely),
  then additional `errors_1.jsonl`, `errors_2.jsonl`,...,
  `errors_N.jsonl` files will be created (N depends on total number of
  failed predictions). These files will have a JSON representation of a
  proto that wraps input text snippet or input text file followed by
  exactly one  ```google.rpc.Status`` <https:%20//github.com/googleapis/
  googleapis/blob/master/google/rpc/status.proto>`__ containing only
  ``code`` and ``message``.  -  For Text Sentiment: In the created
  directory files    ``text_sentiment_1.jsonl``,
  ``text_sentiment_2.jsonl``,...,\ ``text_sentiment_N.jsonl`` will be
  created, where N may be 1, and depends on the total number of inputs
  and annotations found.     ::         Each .JSONL file will contain,
  per line, a JSON representation of a        proto that wraps input
  text snippet or input text file and a list of        zero or more
  AnnotationPayload protos (called annotations), which        have
  text_sentiment detail populated. A single text snippet or file
  will be listed only once with all its annotations, and its
  annotations will never be split across files.         If prediction
  for any text snippet or file failed (partially or        completely),
  then additional `errors_1.jsonl`, `errors_2.jsonl`,...,
  `errors_N.jsonl` files will be created (N depends on total number of
  failed predictions). These files will have a JSON representation of a
  proto that wraps input text snippet or input text file followed by
  exactly one  ```google.rpc.Status`` <https:%20//github.com/googleapis/
  googleapis/blob/master/google/rpc/status.proto>`__ containing only
  ``code`` and ``message``.  -  For Text Extraction: In the created
  directory files    ``text_extraction_1.jsonl``,
  ``text_extraction_2.jsonl``,...,\ ``text_extraction_N.jsonl`` will be
  created, where N may be 1, and depends on the total number of inputs
  and annotations found. The contents of these .JSONL file(s) depend on
  whether the input used inline text, or documents. If input was
  inline, then each .JSONL file will contain, per line, a JSON
  representation of a proto that wraps given in request text snippet's
  "id" (if specified), followed by input text snippet, and a list of
  zero or more AnnotationPayload protos (called annotations), which
  have text\_extraction detail populated. A single text snippet will be
  listed only once with all its annotations, and its annotations will
  never be split across files. If input used documents, then each
  .JSONL file will contain, per line, a JSON representation of a proto
  that wraps given in request document proto, followed by its OCR-ed
  representation in the form of a text snippet, finally followed by a
  list of zero or more AnnotationPayload protos (called annotations),
  which have text\_extraction detail populated and refer, via their
  indices, to the OCR-ed text snippet. A single document (and its text
  snippet) will be listed only once with all its annotations, and its
  annotations will never be split across files. If prediction for any
  text snippet failed (partially or completely), then additional
  ``errors_1.jsonl``, ``errors_2.jsonl``,..., ``errors_N.jsonl`` files
  will be created (N depends on total number of failed predictions).
  These files will have a JSON representation of a proto that wraps
  either the "id" : "" (in case of inline) or the document proto (in
  case of document) but here followed by exactly one
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/bl
  ob/master/google/rpc/status.proto>`__ containing only ``code`` and
  ``message``.  -  For Tables: Output depends on whether  [gcs\_destinat
  ion][google.cloud.automl.v1beta1.BatchPredictOutputConfig.gcs\_destina
  tion] or  [bigquery\_destination][google.cloud.automl.v1beta1.BatchPre
  dictOutputConfig.bigquery\_destination] is set (either is allowed).
  GCS case: In the created directory files ``tables_1.csv``,
  ``tables_2.csv``,..., ``tables_N.csv`` will be created, where N may be
  1, and depends on the total number of the successfully predicted rows.
  For all CLASSIFICATION  [prediction\_type-s][google.cloud.automl.v1bet
  a1.TablesModelMetadata.prediction\_type]: Each .csv file will contain
  a header, listing all columns'  [display\_name-s][google.cloud.automl.
  v1beta1.ColumnSpec.display\_name] given on input followed by M target
  column names in the format of  "<[target\_column\_specs][google.cloud.
  automl.v1beta1.TablesModelMetadata.target\_column\_spec]  [display\_na
  me][google.cloud.automl.v1beta1.ColumnSpec.display\_name]>\_\_score"
  where M is the number of distinct target values, i.e. number of
  distinct values in the target column of the table used to train the
  model. Subsequent lines will contain the respective values of
  successfully predicted rows, with the last, i.e. the target, columns
  having the corresponding prediction
  [scores][google.cloud.automl.v1beta1.TablesAnnotation.score]. For
  REGRESSION and FORECASTING  [prediction\_type-s][google.cloud.automl.v
  1beta1.TablesModelMetadata.prediction\_type]: Each .csv file will
  contain a header, listing all columns'
  [display\_name-s][google.cloud.automl.v1beta1.display\_name] given on
  input followed by the predicted target column with name in the format
  of  "predicted\_<[target\_column\_specs][google.cloud.automl.v1beta1.T
  ablesModelMetadata.target\_column\_spec]  [display\_name][google.cloud
  .automl.v1beta1.ColumnSpec.display\_name]>" Subsequent lines will
  contain the respective values of successfully predicted rows, with the
  last, i.e. the target, column having the predicted target value. If
  prediction for any rows failed, then an additional ``errors_1.csv``,
  ``errors_2.csv``,..., ``errors_N.csv`` will be created (N depends on
  total number of failed rows). These files will have analogous format
  as ``tables_*.csv``, but always with a single target column having
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/bl
  ob/master/google/rpc/status.proto>`__ represented as a JSON string,
  and containing only ``code`` and ``message``. BigQuery case:  [bigquer
  y\_destination][google.cloud.automl.v1beta1.OutputConfig.bigquery\_des
  tination] pointing to a BigQuery project must be set. In the given
  project a new dataset will be created with name ``prediction_<model-
  display-name>_<timestamp-of-prediction-call>`` where will be made
  BigQuery-dataset-name compatible (e.g. most special characters will
  become underscores), and timestamp will be in
  YYYY\_MM\_DDThh\_mm\_ss\_sssZ "based on ISO-8601" format. In the
  dataset two tables will be created, ``predictions``, and ``errors``.
  The ``predictions`` table's column names will be the input columns'  [
  display\_name-s][google.cloud.automl.v1beta1.ColumnSpec.display\_name]
  followed by the target column with name in the format of  "predicted\_
  <[target\_column\_specs][google.cloud.automl.v1beta1.TablesModelMetada
  ta.target\_column\_spec]  [display\_name][google.cloud.automl.v1beta1.
  ColumnSpec.display\_name]>" The input feature columns will contain the
  respective values of successfully predicted rows, with the target
  column having an ARRAY of
  [AnnotationPayloads][google.cloud.automl.v1beta1.AnnotationPayload],
  represented as STRUCT-s, containing
  [TablesAnnotation][google.cloud.automl.v1beta1.TablesAnnotation]. The
  ``errors`` table contains rows for which the prediction has failed, it
  has analogous input columns while the target column name is in the
  format of  "errors\_<[target\_column\_specs][google.cloud.automl.v1bet
  a1.TablesModelMetadata.target\_column\_spec]  [display\_name][google.c
  loud.automl.v1beta1.ColumnSpec.display\_name]>", and as a value has
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/bl
  ob/master/google/rpc/status.proto>`__ represented as a STRUCT, and
  containing only ``code`` and ``message``.
  Attributes:
      destination:
          Required. The destination of the output.
      gcs_destination:
          The Google Cloud Storage location of the directory where the
          output is to be written to.
      bigquery_destination:
          The BigQuery location where the output is to be written to.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.BatchPredictOutputConfig)
    ),
)
_sym_db.RegisterMessage(BatchPredictOutputConfig)

ModelExportOutputConfig = _reflection.GeneratedProtocolMessageType(
    "ModelExportOutputConfig",
    (_message.Message,),
    dict(
        ParamsEntry=_reflection.GeneratedProtocolMessageType(
            "ParamsEntry",
            (_message.Message,),
            dict(
                DESCRIPTOR=_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY,
                __module__="google.cloud.automl_v1beta1.proto.io_pb2"
                # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry)
            ),
        ),
        DESCRIPTOR=_MODELEXPORTOUTPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Output configuration for ModelExport Action.
  Attributes:
      destination:
          Required. The destination of the output.
      gcs_destination:
          The Google Cloud Storage location where the model is to be
          written to. This location may only be set for the following
          model formats: "tflite", "edgetpu\_tflite",
          "tf\_saved\_model", "tf\_js", "core\_ml".  Under the directory
          given as the destination a new one with name "model-export--",
          where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601
          format, will be created. Inside the model and any of its
          supporting files will be written.
      gcr_destination:
          The GCR location where model image is to be pushed to. This
          location may only be set for the following model formats:
          "docker".  The model image will be created under the given
          URI.
      model_format:
          The format in which the model must be exported. The available,
          and default, formats depend on the problem and model type (if
          given problem and type combination doesn't have a format
          listed, it means its models are not exportable):  -  For Image
          Classification mobile-low-latency-1, mobile-versatile-1,
          mobile-high-accuracy-1: "tflite" (default), "edgetpu\_tflite",
          "tf\_saved\_model", "tf\_js", "docker".  -  For Image
          Classification mobile-core-ml-low-latency-1,    mobile-core-
          ml-versatile-1, mobile-core-ml-high-accuracy-1:    "core\_ml"
          (default). Formats description:  -  tflite - Used for Android
          mobile devices. -  edgetpu\_tflite - Used for `Edge    TPU
          <https://cloud.google.com/edge-tpu/>`__ devices. -
          tf\_saved\_model - A tensorflow model in SavedModel format. -
          tf\_js - A `TensorFlow.js <https://www.tensorflow.org/js>`__
          model    that can be used in the browser and in Node.js using
          JavaScript. -  docker - Used for Docker containers. Use the
          params field to    customize the container. The container is
          verified to work correctly    on ubuntu 16.04 operating
          system. See more at [containers  quickstart](https:
          //cloud.google.com/vision/automl/docs/containers-gcs-
          quickstart) \* core\_ml - Used for iOS mobile devices.
      params:
          Additional model-type and format specific parameters
          describing the requirements for the to be exported model
          files, any string must be up to 25000 characters long.  -  For
          ``docker`` format: ``cpu_architecture`` - (string) "x86\_64"
          (default). ``gpu_architecture`` - (string) "none" (default),
          "nvidia".
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ModelExportOutputConfig)
    ),
)
_sym_db.RegisterMessage(ModelExportOutputConfig)
_sym_db.RegisterMessage(ModelExportOutputConfig.ParamsEntry)

ExportEvaluatedExamplesOutputConfig = _reflection.GeneratedProtocolMessageType(
    "ExportEvaluatedExamplesOutputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Output configuration for ExportEvaluatedExamples Action. Note that
  this call is available only for 30 days since the moment the model was
  evaluated. The output depends on the domain, as follows (note that
  only examples from the TEST set are exported):  -  For Tables:  [bigqu
  ery\_destination][google.cloud.automl.v1beta1.OutputConfig.bigquery\_d
  estination] pointing to a BigQuery project must be set. In the given
  project a new dataset will be created with name
  ``export_evaluated_examples_<model-display-name>_<timestamp-of-export-
  call>`` where will be made BigQuery-dataset-name compatible (e.g. most
  special characters will become underscores), and timestamp will be in
  YYYY\_MM\_DDThh\_mm\_ss\_sssZ "based on ISO-8601" format. In the
  dataset an ``evaluated_examples`` table will be created. It will have
  all the same columns as the  [primary\_table][google.cloud.automl.v1be
  ta1.TablesDatasetMetadata.primary\_table\_spec\_id] of the
  [dataset][google.cloud.automl.v1beta1.Model.dataset\_id] from which
  the model was created, as they were at the moment of model's
  evaluation (this includes the target column with its ground truth),
  followed by a column called "predicted\_". That last column will
  contain the model's prediction result for each respective row, given
  as ARRAY of
  [AnnotationPayloads][google.cloud.automl.v1beta1.AnnotationPayload],
  represented as STRUCT-s, containing
  [TablesAnnotation][google.cloud.automl.v1beta1.TablesAnnotation].
  Attributes:
      destination:
          Required. The destination of the output.
      bigquery_destination:
          The BigQuery location where the output is to be written to.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ExportEvaluatedExamplesOutputConfig)
    ),
)
_sym_db.RegisterMessage(ExportEvaluatedExamplesOutputConfig)

GcsSource = _reflection.GeneratedProtocolMessageType(
    "GcsSource",
    (_message.Message,),
    dict(
        DESCRIPTOR=_GCSSOURCE,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The Google Cloud Storage location for the input content.
  Attributes:
      input_uris:
          Required. Google Cloud Storage URIs to input files, up to 2000
          characters long. Accepted forms: \* Full object path, e.g.
          gs://bucket/directory/object.csv
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.GcsSource)
    ),
)
_sym_db.RegisterMessage(GcsSource)

BigQuerySource = _reflection.GeneratedProtocolMessageType(
    "BigQuerySource",
    (_message.Message,),
    dict(
        DESCRIPTOR=_BIGQUERYSOURCE,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The BigQuery location for the input content.
  Attributes:
      input_uri:
          Required. BigQuery URI to a table, up to 2000 characters long.
          Accepted forms: \* BigQuery path e.g.
          bq://projectId.bqDatasetId.bqTableId
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.BigQuerySource)
    ),
)
_sym_db.RegisterMessage(BigQuerySource)

GcsDestination = _reflection.GeneratedProtocolMessageType(
    "GcsDestination",
    (_message.Message,),
    dict(
        DESCRIPTOR=_GCSDESTINATION,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The Google Cloud Storage location where the output is to be written
  to.
  Attributes:
      output_uri_prefix:
          Required. Google Cloud Storage URI to output directory, up to
          2000 characters long. Accepted forms: \* Prefix path:
          gs://bucket/directory The requesting user must have write
          permission to the bucket. The directory is created if it
          doesn't exist.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.GcsDestination)
    ),
)
_sym_db.RegisterMessage(GcsDestination)

BigQueryDestination = _reflection.GeneratedProtocolMessageType(
    "BigQueryDestination",
    (_message.Message,),
    dict(
        DESCRIPTOR=_BIGQUERYDESTINATION,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The BigQuery location for the output content.
  Attributes:
      output_uri:
          Required. BigQuery URI to a project, up to 2000 characters
          long. Accepted forms: \* BigQuery path e.g. bq://projectId
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.BigQueryDestination)
    ),
)
_sym_db.RegisterMessage(BigQueryDestination)

GcrDestination = _reflection.GeneratedProtocolMessageType(
    "GcrDestination",
    (_message.Message,),
    dict(
        DESCRIPTOR=_GCRDESTINATION,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The GCR location where the image must be pushed to.
  Attributes:
      output_uri:
          Required. Google Contained Registry URI of the new image, up
          to 2000 characters long. See  https:
          //cloud.google.com/container-registry/do // cs/pushing-and-
          pulling#pushing\_an\_image\_to\_a\_registry Accepted forms: \*
          [HOSTNAME]/[PROJECT-ID]/[IMAGE] \* [HOSTNAME]/[PROJECT-
          ID]/[IMAGE]:[TAG]  The requesting user must have permission to
          push images the project.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.GcrDestination)
    ),
)
_sym_db.RegisterMessage(GcrDestination)


DESCRIPTOR._options = None
_INPUTCONFIG_PARAMSENTRY._options = None
_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY._options = None
# @@protoc_insertion_point(module_scope)
